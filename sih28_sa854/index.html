<html>
<head>
    <link rel="stylesheet" href="style.css">
</head>

<body>
    <body style="margin:0;padding:40">
	<h1>Outlet Nanny</h1>
        <p>
		Saleh Hassen, sih28 <br> Samad Arshad, sa854 <br>
        </p>
    
        <p>
        In this project, we monitor the power usage of everyday devices and control them through a serial interface.
        </p>
    
        <img src="OutletNanny.jpg" alt="Device"
        style="width:800px;height:450px;">
        
        <h2>Table of Contents</h2><h3>
        <ul class="circle">
        <li><a href="#Introduction">Introduction</a></li>
        <li><a href="#HLDesign">High Level Design</a></li>
          <ul class="decimal">
          <li><a href="#BGMath">Background Math</a></li>
          <li><a href="#LStructure">Logical Structure</a></li>
          <li><a href="#tradeoffs">Trade-offs</a></li>
            <ul class="decimal">
            <li><a href="#Htradeoffs">Hardware</a></li>
            <li><a href="#Stradeoffs">Software</a></li>
            </ul>
          <li><a href="#NEC">National Electrical Code (NEC) Standards</a></li>
          <li><a href="#patenting">Patenting</a></li>
          </ul>
        <li><a href="#PHDesign">Program and Hardware Design</a></li>
          <ul class="decimal">
          <li><a href="#PDetails">Program Details</a></li>
            <ul class="decimal">
            <li><a href="#Python">Main Computer</a></li>
              <ul class="decimal">
              <li><a href="#UI">User Interface</a></li>
              <li><a href="#Plotting">Plotting</a></li>
              </ul>
            <li><a href="#PIC32">PIC32</a></li>
              <ul class="decimal">
              <li><a href="#ADC">ADC & Timer Interrupts</a></li>
              <li><a href="#UART">UART</a></li>
              <li><a href="#Timer">Timer</a></li>
              <li><a href="#Main">Main</a></li>
              </ul>
            </ul>
          <li><a href="#SRef">Software References</a></li>
          <li><a href="#HDetails">Hardware Details</a></li>
            <ul class="decimal">
            <li><a href="#OBox">Outlet Box</a></li>
            <li><a href="#PCircuitry">PIC32 Peripheral Circuitry</a></li>
            </ul>
          <li><a href="#HRef">Hardware References</a></li>
          <li><a href="#Bumps">Bumps in the Road</a></li>
          </ul>
        <li><a href="#results">Results</a></li>
          <ul class="decimal">
          <li><a href="#speed">Speed</a></li>
          <li><a href="#accuracy">Accuracy</a></li>
          <li><a href="#safety">Safety</a></li>
          <li><a href="#use">Usability</a></li>
          </ul>
        <li><a href="#conc">Conclusions</a></li>
          <ul class="decimal">
          <li><a href="#refl">Reflection</a></li>
          <li><a href="#safetystandards">Safety Standards Consideration</a></li>
          <li><a href="#intel">Intellectual Property</a></li>
          <li><a href="#ethics">IEEE Code of Ethics</a></li>
          </ul>
        <li><a href="#Appendix">Appendix</a></li>
        </ul>
        </h3>
    
        <a name="Introduction"></a>
        <h2>Introduction</h2>
        <p>
        We designed a power monitor that could communicate with the PIC32 through UART to give both power and current readings for any device(s) (that use NEMA plugs) plugged into our box. These readings are then accessible on a website interface, on a graph. We chose to do this project because of the growing issue of climate change and power management, allowing the client to measure their power usage and current draw. Not only that, but it’s also useful to know how much power that everyday devices use up, to minimize electricity bills.
        </p>
    
        <p>
        With Saleh moving into an apartment and concerned about electricity bills for the devices he used, he wanted to measure how much power he consumes with most of his devices along with his roommates and would like to have remote control of when the devices receive power. For devices that used a fixed amount of power when on this was trivial, but certain products such as a desktop and dynamic light strip vary over time. In addition, several devices still act as a load while the device is off and he wanted a quick and safe way to monitor those devices too. The intention was to have this device connected to the internet on a private server so that a web gui can entirely control when the device is on/off and perform data acquisition on the collected information.
        </p>
    
        <p>
        Unfortunately, due to time and resource constraints, we ended up dropping this feature, mostly due to the outlet box experiencing failure and having to remanufacture the outlet box from this. 
        </p>

        <a name="HLDesign"></a>
        <h2>High Level Design</h2>
            <a name="BGMath"></a>
            <h3>Background Math</h3>
            <p>To compute power consumption, you would need the root-mean-square (RMS) of the voltage and current over one period across the device’s terminals. To simplify our project we assume the ac line is 120V that’s a pure sinusoid at 60Hz. We then measure the instantaneous current and somehow compute the RMS current, assuming the current is in phase with the AC voltage. <br> <br>
    
            Some background math we had to do included:
            <br>
            - Calculating expected current readings from different devices
            <br>
            - Getting minimum and maximum values from the ADC during a short period to get a peak-to-peak value
            <br>
            - Creating a linear equation to map those peak-to-peak values to a current
            <br>
            </p>
            
            <a name="LStructure"></a>
            <h3>Logical Structure</h3>
            <img src="logical_struc.png" alt="Logical structure"
            style="width:600px;height:440px;">
            
            <p>
            Our device required development on three fronts, the power path (which we nicknamed the Outlet box), the PIC32 code and peripheral circuitry for control, sampling and simple LED interface, and the computer scripts used to expand the project.
            </p>
            
            <img src="outnanny.PNG" alt="Outlet Nanny"
            style="width:440px;height:480px;">
            
            <p>
            The outlet box is responsible for connecting the power path and providing the current sensor output needed for the PIC32 to process. The PIC32 then drives status LEDs to display basic details, measures current seen from the current sensor, provides a serial command interface for a device to request values / actions, and limits current if the measured value is greater than the set cap for an extended period of time. The onboard computer scripts initially turn on the relay, periodically request a current reading through serial, store this in a file, and plot the data over time.
            </p>
            
            <a name="tradeoffs"></a>
            <h3>Trade-offs</h3>
                <a name="Htradeoffs"></a>
                <h4>Hardware</h4>
                <p>
                We considered a few tradeoffs for hardware and software when developing the device. We had the intention of incorporating the a Raspberry Pi into our project for website hosting and IoT, due to the wi-fi capabilities not working as expected and us running out of time on the project, we ended up dropping this feature. This worked in our favor in terms of our device efficiency since this would have consumed 0.5A of DC current on it’s own, making our device more wasteful to power the overhead. In addition, the 5V power brick in use was limited to 1A DC, with the relay taking up 0.2A DC, this would have put us close to over budget for DC current consumption. In hindsight we realized a ESP8266 would have been a better fit for providing the needed connection to the internet and the use of a carbon neutral server such as Google Cloud to provide the web gui to interact with the device remotely.
                </p>
                
                <p>
                The other major consideration was the maximum rating of current we wanted our device to be capable of measuring. Considering we wanted to make a discrete device that would fit in a 2 Gang Outlet box and reaching out to Bruce, we decided a max (AC) current rating of 5A would be appropriate. Had we had a greater amount of time to develop the product, we would have made a Computer Aided Design of the mechanical structure to get everything much more compact and developed a PCB for convenient connections for (both the power path and PIC32). Our current sensor wasn’t too sensitive (100mV precision) or had that high of a rating (+/- 20A), but it came at a lower cost for that reason, and most devices in lab were within the limit of sufficiently accurate results.
                </p>
                
                <a name="Stradeoffs"></a>
                <h4>Software</h4>
                <p>
                To measure the current sensor output, we sampled from our ADC at a regular interval and computed the peak to peak seen. We could have used FFT to give us a greater idea of not only the current at the line frequency, but harmonics produced by the device. Although this would have been handy for determining device power factor, which could be used to determine theoretical efficiency, we used sampling for the ADC readings because it was simpler to implement and required much less computation. In addition, we considered plotting the data through the PIC32 on a TFT instead of using a web app interface but decided to push for some kind of web app interface in case we could get the project to work with Wi-Fi.
                </p>
                
            
            <a name="NEC"></a>
            <h3>National Electrical Code (NEC) Standards</h3>
            <p>
            Our device keeps the safety of the client in mind, following electrical regulations of the <a href="https://archive.org/details/gov.law.nfpa.nec.2014/page/n5">2014 National Electrical Code</a> within our judgement. The device is made such that accidental contact with the live AC line (120V RMS) is prevented. The Outlet box encloses all of the power path and only provides exposure to this through the client outlets and the supply plug, both of which if used properly should protect the user [<a href="https://archive.org/details/gov.law.nfpa.nec.2014/page/n45">110.27(A)</a>]. We have our own lockout/tagout procedure for our device where if working on the Outlet box circuit, we place electrical tape on the supply plug to prevent accidental energization and we remove the front plate to access it’s contents. When done accessing the Outlet box circuit we placed the front plate back on and re-energize the device. Even though the front plate doesn’t fit the PVC box snuggly, we are able to screw in the plate to the switch and use electrical tape to reinforce the protruding portions to the box. We also maintain color convention for both practice and the US National Electrical code in our power path assigning black to primary (supply) hot, white to neutral, green to AC (Protective) Ground, and red for secondary (client) hot [<a href="https://www.allaboutcircuits.com/textbook/reference/chpt-2/wiring-color-codes/">AllAboutCircuits</a>]. We pass the client ground and neutral connections on the client outlet from the supply side and pass the hot connection after the relay to client hot. Note that the electrical code states we cannot use neutral for more than one branch of the circuit unless “enters from a cable unique to the circuit that makes the grouping obvious” [<a href="https://archive.org/details/gov.law.nfpa.nec.2014/page/n52">200.4</a>]. The last regulation we’ll talk about is on Outlet Device Ampere rating where our device must be able to manage a current not less than the load to be served [<a href="https://archive.org/details/gov.law.nfpa.nec.2014/page/n61">210.21</a>]. Since we designed our Outlet box to not handle more than 5A I RMS of AC current and the box is designed to shut off the relay if such current or higher is pulled, our device meets this constraint assuming the user doesn’t set change the limit to be higher than the default. We allowed the user to change the limit greater than this for debugging and forgot to prevent this.
            </p>
            
            <a name="patenting"></a>
            <h3>Patenting</h3>
            <p>
            We realized as we were writing this report that <a href="https://patents.google.com/patent/US9106099B2/en">there is a patent for a “power monitoring system” that is very similar to our project</a>, receives power from a main supply line, offers that power conditionally to several client devices, and monitors there power consumption. In addition, they also use a microcontroller for all their data processing and control logic. 
            </p>
            
            <p>
            This patent document also includes this statement:
            <blockquote>
            “Depending on the nature of the functional state of the device and the nature of the other electrical devices, the supply of power to any or all of the other electrical devices can be shut off, so that not all electrical devices are powered in situations where power to them is unnecessary.”
            </blockquote>
            </p>
            
            <p>
            This is one of the functions of our power monitor device, where a current limit can be placed where if that limit is surpassed, the power relay is shut off.
            </p>
            
            <p>
            Not only that, but related to our user interface (UART):
            <blockquote>
            “the invention provides a user interface for use with . . . means for  receiving data output from the monitoring device relating to the monitored power output; signalling means for sending a signal in response to the received data; and control means for communicating with the monitoring device to effect a change in power consumption of at least one of the electrical devices”
            </blockquote>
            </p>
            
            <p>
            The patent linked, however, is a patent for a wired device using broad language in terms of control, communication, and distribution making it easier for our product to be included. While our original project idea was to have a wireless IoT power monitor, we ran into issues getting to finish the web portion of our project. Fortunately the patent expired in the US on December 16th, 2019.
            </p>
    
        <a name="PHDesign"></a>
        <h2>Program and Hardware Design</h2>
            <a name="PDetails"></a>
            <h3>Program Details</h3>
                <a name="Python"></a>
                <h4>Main Computer<h4>
                <p>
                    <a name="UI"></a>
                    <h5>User Interface</h5>
                    <p>
                    Our user-interface is controlled by a Python script named sera.py that reads the user’s inputs into a console, and can return useful information to the user when giving a command, such as entering 'r' to request the status of the relay, printing the current reading in a readable manner, and giving feedback of the results of entering a command like setting the current limit.
                    </p>
                    
                    <img src="getandsetcurrent.PNG" alt="Current"
                    style="width:580px;height:564px;"><br>
                    
                    <a name="Plotting"></a>
                    <h5>Plotting</h5>
                    <p>
                    We can plot the current values given by getCurrent() by using serial_and_pyplot.py—it appends the values to a CSV file, along with the time they were read, automatically. It also reads the CSV file and graphs a figure including every point, showing the value of the current with respect to time. This figure is saved as an image, and is able to be seen on an HTML webpage which automatically refreshes every 5 seconds, so that we can see the changes the current sensor has detected in the past 5 seconds.
                    </p>
                    
                    <img src="readcsv.PNG" alt="Read CSV"
                    style="width:800px;height:450px;"><br>
                  
                    <p>
                    We also graph power usage as a function of time, using the same values of the current readings, but multiplied by 120.
                    </p>
                    
                    <img src="plotter.PNG" alt="Plotter"
                    style="width:300px;height:270px;">
                    
                </p>
                
                <a name="PIC32"></a>
                <h4>PIC32</h4>
                <p>
                We implemented our PIC32 code for the Outlet Nanny using a timer interrupt, a timer thread, a command thread, and child UART threads to send/receive. The main function initializes our setup and does round robin scheduling between the timer and command thread using Protothreads.
                </p>
                    <a name="ADC"></a>
                    <h5>ADC & Timer Interrupts</h5>
                    <img src="timer.png" alt="Timer thread"
                    style="width:400px;height:480px;">
                    
                    <p>
                    
                    We sampled at regular intervals of 3 kHz, 50 times the line frequency of 60 Hz, to get instantaneous current readings. To compute the peak 2 peak current sensor output seen on the ADC, we would store a local maximum/minimum per period and overwrite this once a new max / min was seen. Once the period had finished, point_num is 50, we took the difference to get the peak to peak signal seen in terms of 10 bit ADC reading, then we cleared the local max / min. We would then determine the current empirically. Through several devices with fixed power ratings and a 120V rms ac line, we estimated the expected rms current and used a line of best fit with Google Sheets to determine how to translate a peak to peak ADC to rms current. The current sensor is expected to deviate from it’s 2.5V bias by the one tenth of the current flowing through the device. With the transfer function seen after the low pass filter, the 10 bit ADC that uses 3.3V as reference, and the assumption that the current is a 60Hz pure sinusoid, you get the equation below.
                    </p>
                    
                    <img src="equations.PNG" alt="Equations"
                    style="width:400px;height:320px;">
                    
                    <p>
                    Our experimentally determined equation is very similar and we talk about possible reasons for the small discrepancy in our results section.
                    </p>
                    
                    <p>
                    We then reset our interrupt counter, preparing for a new period of current sensor data to poll. Lastly, once the RMS current seen by the sensor is computed we check if this is above the limit specified by the user with the ‘l’ command, if so increment the overcurrent counter, oc_cntr, by one, otherwise reset this counter to zero. This value is compared in our timer thread to determine if the device should switch to current protection mode.
                    </p>
                    
                    <a name="UART"></a>
                    <h5>UART</h5>
                    <img src="cmd.PNG" alt="Command thread"
                    style="width:550px;height:560px;">
                    
                    <p>
                    A thread is used to manage UART Serial communication so the microcontroller appears as a command interface when interacting with it through PuTTY. We prompt the user the device is on and continually take in their input with PT_GetSerialBuffer, use sscanf to parse command arguments from the char array, and use PT_DMA_PutSerialBuffer to transmit a response, similar to Serial_1_2_3_test_all.c and Lab 3, however our code is a little less efficient and instead of using case statements we use if/else conditionals. The user can enter up to 16 characters per command, where the first letter is the command type and the character following this and a space character are the input argument, and terminate the command by pressing the enter/return key. One command is the user manually setting/clearing the relay, they can control it if the device isn’t in current protection mode, if so a nonzero input turns on the relay by clearing the relay control signal on the PIC32. Note that a Red LED is set and cleared the complement of the PIC32 control signal to display that the Relay is on, providing power to the client outlet sockets. A zero input sets the control signal, disabling the relay. Then a confirmation message is sent. If the device is in current protection mode, the relay control signal isn’t adjusted and the user is prompted the device is current limited. In addition other commands are:
                    
                    <ul>
                    <li>m (to manually get out of current protection mode)</li>
                    <li>i (report last rms current computed)</li>
                    <li>p (report power reading based on last current reading)</li>
                    <li>l (adjust current limit to argument value)</li>
                    <li>s (get status, whether the device is in current protection mode)</li>
                    <li>a (report raw adc reading last seen)</li>
                    </ul>
                    
                    If the user input doesn’t fall under any of the above commands, the user is prompted the command is unknown. Unfortunately this implementation is space sensitive, but is still functional and reliable. This thread yields every 100 milliseconds to give other threads several opportunities to execute, especially back when we attempted Fast Fourier Transforms for current sensor data parsing. However this yield time prevents the parsing of a command sent less than 100 ms after the previous one.
                    </p>
                    
                    <p>
                    We use the human readable variant of the GetSerialBuffer child thread with a modification, when interacting exclusively with a human, we use the Protothreads header as is and each character received is sent back for user feedback. However once we wanted our python scripts for the computer to parse the serial response, we decided to comment out the portion of UART that sends all characters received. The machine buffer also offers this but requires more work to do so and doesn’t yield waiting for the user to input a new character but yields based on whether a DMA transfer is done. With humans typing relatively slow to the UART data transaction, we get better CPU Utilization using the human readable pthread. Even when our computer is interacting with the device via python script since we would want to send our commands only so often. To make this change we only need to vary GetSerialBuffer in pt_cornell_1_3_2.h.
                    </p>
                    
                    <a name="Timer"></a>
                    <h5>Timer</h5>
                    <img src="pic32timer.png" alt="PIC32 timer thread"
                    style="width:460px;height:380px;">
                    
                    <p>
                    A timer thread is used to toggle a heartbeat LED and check if the device over current counter is over 100, which means for over 1.6 seconds the RMS current is greater than the limit.  Under this condition, the current protection LED is set, and the relay (with it’s LED) is shut off, cutting off client power outlet sockets. The reason why we check if we pulled our current limit for a set amount of time in the timer thread was to guarantee the device cannot enter current protection mode in less than a second of duration with the thread acting as a buffer since this thread can only execute once a second and the timer oc_cntr is required to be greater than 100. Since the counter can only increment at 60Hz, the first execution of the timer thread immediately after the oc_cntr is reset to zero can’t set off current protection mode.
                    </p>
                    
                    <a name="Main"></a>
                    <h5>Main</h5>
                    <img src="main.png" alt="PIC32 timer thread"
                    style="width:460px;height:160px;">
                    
                    <p>
                    In our main function, we first disable analog inputs by clearing the analog select registers and then setup our ADC. We used an initial setup of our ADC similar to Bruce’s <a href="http://people.ece.cornell.edu/land/courses/ece4760/PIC32/Target_board/version_1_3_2/TFT_ADC_read.c">TFT_ADC_read.c</a>. We use the 3.3V voltage rails with no auto sampling (meaning we need to acquire a sample before reading from our ADC), no offset calibrated, using half the system clock speed (20 MHz), using analog channel 11 (Pin RB13). We then configure a timer such that it occurs at a rate of 3 kHz (compromised to 3,004.8 Hz to use a larger prescaler from peripheral clock).  Afterwards we declared our Digital outputs, as shown below.
                    </p>
                    
                    <img src="outputtable.PNG" alt="Outputs"
                    style="width:270px;height:240px;">
                    
                    <p>
                    We then enable interrupts and then begin initializing our two parent protothreads: timer and cmd. The child threads (for UART transmit/receive) do not have to be initialized here and are spawned as needed. Finally we execute the threads with a round-robin scheduler utilizing a while loop.
                    </p>
                    
                    <img src="interrupts.PNG" alt="Interrupts"
                    style="width:475px;height:260px;"><br>
            
            <a name="SRef"></a>
            <h3>Software References</h3>
            <a href="https://pyserial.readthedocs.io/">pySerial Library and Examples</a><br>
            <a href="https://matplotlib.org/">Matplotlib Library and Examples</a><br>
            <a href="http://people.ece.cornell.edu/land/courses/ece4760/">Professor Land’s ADC/UART code (Labs 2 and 3) and his Protothreads interface</a><br>
                    
            <a name="HDetails"></a>    
            <h3>Hardware Details</h3>
                <a name="OBox"></a>
                <h4>Outlet Box</h4>
                <img src="outletbox_schem.png" alt="Outlet box"
                style="width:760px;height:400px;"><br>
                
                <a name="PCircuitry"></a>
                <h4>PIC32 Peripheral Circuitry</h4>
                <img src="board_and_per.png" alt="PIC32"
                style="width:760px;height:400px;"><br>
            
            <a name="HRef"></a>
            <h3>Hardware References</h3>
            <a href="http://people.ece.cornell.edu/land/courses/ece4760/PIC32/index_UART.html">Universal Asynchronous Receiver-Transmitter (UART) Serial</a><br>
            <a href="http://people.ece.cornell.edu/land/courses/ece4760/PIC32/index_ADC.html">Analog-to-Digital Converter</a><br>
            <a href="https://en.wikipedia.org/wiki/AC_power_plugs_and_sockets">AC Plugs and Sockets</a><br>
            <a href="https://docs.broadcom.com/docs/ACHS-712x-DS101">ACHS 7122 (Current Sensor) Datasheet</a><br>
            <a href="https://www.mouser.com/datasheet/2/307/g3ne_ds_e_4_1_csm166-1221231.pdf">G3NE-210T-US-DC5 (Relay) Datasheet</a><br>
            <a href="https://www.lowes.com/pd/CARLON-2-Gang-Blue-PVC-New-Work-Standard-Switch-Outlet-Wall-Electrical-Box/50053877">PVC 2-Gang Outlet Box</a><br>
            <a href="https://www.lowes.com/pd/Legrand-White-15-Amp-Duplex-Residential-Outlet/3235958">Duplet Outlet Socket</a><br>
            <a href="https://www.lowes.com/pd/Eaton-15-Amp-Single-pole-White-Toggle-Residential-Light-Switch/1098293 ">SPST Switch 120V/15A</a><br>
            <a href="https://www.lowes.com/pd/Legrand-2-Gang-White-Double-Standard-Wall-Plate/1000397809?cm_mmc=shp-_-c-_-prd-_-rpe-_-google-_-pla-_--_-soswiringdevices-_-1000397809-_-0&placeholder=null&gclid=EAIaIQobChMIodaLxbK75gIVjJ-zCh0PnwjVEAQYASABEgL7mfD_BwE&gclsrc=aw.ds">2-Gange Outlet and Switch Plate</a><br>
            <a href="https://nurdspace.nl/images/e/e0/ESP8266_Specifications_English.pdf">Considered: ESP8226 (Wifi Module) Datasheet</a><br>
            
            <a name="Bumps"></a>
            <h3>Bumps in the Road</h3>
            <ul>
            <li>The Raspberry Pi Zero W’s internet capabilities did not work with Cornell’s wi-fi.</li>
            <li>Some electrical devices cause UART to send seemingly random characters.</li>
            <li>Using a small container for our device rather than a larger one made hardware debugging slightly more time consuming.</li>
            <li>The current sensor broke at one point, and we couldn’t get any oscilloscope readings, forcing us to replace it.</li>
            <li>We tried building a current sensor ourselves when our first one broke, but it ended up not working.</li>
            <li>Using FFT for the ADC readings was a futile effort, as the regular sampling method was what we ended up using, and it was within about 11% error of actual values. The FFT implementation was not worth the time and effort, but could be a good improvement in the future.</li>
            </ul>
        
        <a name="results"></a>
        <h2>Results</h2>
            <a name="speed"></a>
            <h3>Speed</h3>
            <p>
            Our UART sends a data point about once a second, and our web page containing the graph of the current readings as a function of time refreshes every five seconds. All commands sent through UART give virtually instant results. The delay between the actual current value and the data sent through UART is negligible when we remove the one second delay.
            </p>
            
            <a name="accuracy"></a>
            <h3>Accuracy</h3>
            <img src="accuracy.PNG" alt="Accuracy data"
            style="width:500px;height:320px;">
            <p>
            Our current readings were within about 11% of the expected results.The current sensor device itself has an error margin of 10%, so we think we’ve done a good job at keeping the error relatively low.
            </p>
            
            <a name="safety"></a>
            <h3>Safety</h3>
            <p>
            To ensure our project is a safe product, none of our wires were exposed, and they were well-insulated, both in the outlet box and outside of it. We made sure every connection besides those on the PIC32 were soldered well to avoid any open circuits. Our device also included a switch, which can turn off the device completely. In our UART program, our system starts with the relay off (r = 0) as an additional safeguard. Most of the wires used in this device are contained in a small PVC box that we screwed shut, so there’s absolutely no exposed wiring in our device. Finally, there’s a default current limit set when the device is connected, which is 5A. If the current sensor reads any current value higher than this, it will turn off the relay.
            </p>
            
            <a name="use"></a>
            <h3>Usability</h3>
            <p>
            Our device starts with ‘safe’ default settings (the relay is off, current limit is 5A) for first-time users. When giving a command in the serial console, the result of the command is echoed back to the user, so that they can see if their command went through, and what the result of it was. The only way someone could hurt themselves using this device is by either breaking it open and ripping the insulation off, or sticking a piece of metal into the electrical outlets.
            </p>
        
        <a name="conc"></a>
        <h2>Conclusions</h2>
            <a name="refl"></a>
            <h3>Reflection</h3>
            <p>
            During the project, we were worried about the accuracy of our current readings, and once we tested them, we ended up seeing that our accuracy was very close to the accuracy margin of the current sensor itself—11% vs 10%. 
            </p>
            
            <p>
            When we started this project, we expected Raspberry Pi implementation to not be the most difficult part, but for reasons we don’t really understand, our Raspberry Pi couldn’t work with Cornell’s wi-fi, that or it was broken. Because of this, our device must be wired to a computer to read the current values, which was not what we originally wanted.
            </p>
            
            <p>
            We <i>did</i> expect the hardware work to be the most time-consuming part of our project, and that it was. As for hardware debugging, aside from needing to replace the current sensor because our first one was fried, we hit our goal of not having to do much in that regard.
            </p>
            
            <p>
            If we had to improve upon or extend our project, we would definitely figure out how to implement the Raspberry Pi and wi-fi functionality, as well as make our web GUI look much more appealing, and be able to control the device without typing into a console. FFT also could be considered if time permitted and if we were sure that it would even improve our results.
            </p>
            
            <a name="safetystandards"></a>
            <h3>Safety Standards and Consideration</h3>
            Our device cannot harm someone unless the PVC box and/or the insulation is broken, or if someone sticks a piece of metal in any of the outlets, like any regular home outlet. We’ve insulated every previously exposed wire or hot connections. Our device can also be turned off without needing to be unplugged, by using the switch. We have followed 
            
            <a name="intel"></a>
            <h3>Intellectual Property</h3>
            <p>We based our code for UART communication off of Bruce’s given code for Lab 3, and we also used his Protothreads interface. Our Python UART-read code was based off of simple examples and documentation given for the library “PySerial”, and the same for the Python library “Matplotlib”.</p>
            <p>No patent opportunities are foreseen for the project at this point.</p>
            
            <a name="ethics"></a>
            <h3>IEEE Code of Ethics</h3>
            We have agreed to follow IEEE’s code of ethics before doing this project, some specific steps we’ve taken to ensure this are:
            <ul>
            <li>We have made our device so that it's not any more dangerous than a regular electrical outlet.</li>
            <li>We only use actual data to make any claims and estimates.</li>
            <li>We’ve talked with Bruce about our limitations and we’ve taken the correct safety precautions working on this project.</li>
            <li>We have followed standard IEEE safety precautions when working with this project.</li>
            </ul>
            
        <a name="Appendix"></a>
        <h2>Appendix</h2>
        <p>The group approves this report for inclusion on the course website.</p>
        <p>The group approves the video for inclusion on the course youtube channel.</p>
        
            <h3>Program Listing</h3>
                <h4>Main PIC32 Code (C)</h4>
                <script src="https://gist.github.coecis.cornell.edu/sa854/02f1bfe4bb95721645039193cc85bb31.js"></script>
                
                <h4>Serial Input Code (Python)</h4>
                <script src="https://gist.github.coecis.cornell.edu/sa854/1076f20a1d3a5af53e89a9eecda933fe.js"></script>
                
                <h4>Current Plotting Code (Python)</h4>
                <script src="https://gist.github.coecis.cornell.edu/sa854/c6571ed1ee67a54ce8ab19057522a352.js"></script>
                
                <!--<h4>Edited pt_cornell_1_3_2.h</h4>
                <script src="https://gist.github.coecis.cornell.edu/sa854/6608aff0b39048ff4e2c97c5667d2ca5.js"></script>-->
            
            <h3>Hardware Schematics</h3>
            <img src="outletbox_schem.png" alt="Outlet box"
            style="width:760px;height:400px;">
            <img src="board_and_per.png" alt="PIC32"
            style="width:760px;height:400px;">
            
            <h3>Full Source Listing</h3>
            <a href="https://pyserial.readthedocs.io/">pySerial Library and Examples</a><br>
            <a href="https://matplotlib.org/">Matplotlib Library and Examples</a><br>
            <a href="http://people.ece.cornell.edu/land/courses/ece4760/">Professor Land’s ADC/UART code (Labs 2 and 3) and his Protothreads interface</a><br>
            <a href="http://people.ece.cornell.edu/land/courses/ece4760/PIC32/index_UART.html">Universal Asynchronous Receiver-Transmitter (UART) Serial</a><br>
            <a href="http://people.ece.cornell.edu/land/courses/ece4760/PIC32/index_ADC.html">Analog-to-Digital Converter</a><br>
            <a href="https://en.wikipedia.org/wiki/AC_power_plugs_and_sockets">AC Plugs and Sockets</a><br>
            <a href="https://docs.broadcom.com/docs/ACHS-712x-DS101">ACHS 7122 (Current Sensor) Datasheet</a><br>
            <a href="https://www.mouser.com/datasheet/2/307/g3ne_ds_e_4_1_csm166-1221231.pdf">G3NE-210T-US-DC5 (Relay) Datasheet</a><br>
            <a href="https://www.lowes.com/pd/CARLON-2-Gang-Blue-PVC-New-Work-Standard-Switch-Outlet-Wall-Electrical-Box/50053877">PVC 2-Gang Outlet Box</a><br>
            <a href="https://www.lowes.com/pd/Legrand-White-15-Amp-Duplex-Residential-Outlet/3235958">Duplet Outlet Socket</a><br>
            <a href="https://www.lowes.com/pd/Eaton-15-Amp-Single-pole-White-Toggle-Residential-Light-Switch/1098293 ">SPST Switch 120V/15A</a><br>
            <a href="https://www.lowes.com/pd/Legrand-2-Gang-White-Double-Standard-Wall-Plate/1000397809?cm_mmc=shp-_-c-_-prd-_-rpe-_-google-_-pla-_--_-soswiringdevices-_-1000397809-_-0&placeholder=null&gclid=EAIaIQobChMIodaLxbK75gIVjJ-zCh0PnwjVEAQYASABEgL7mfD_BwE&gclsrc=aw.ds">2-Gange Outlet and Switch Plate</a><br>
            <a href="https://nurdspace.nl/images/e/e0/ESP8266_Specifications_English.pdf">Considered: ESP8226 (Wifi Module) Datasheet</a><br>


</body>
</html>