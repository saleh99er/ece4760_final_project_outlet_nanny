<html>
<head>
<div class="header">
<title>Outlet Nanny</title>
<h1>The Outlet Nanny</h1>
</div>
<link rel="stylesheet" href="style.css">
</head>
 <style>
body {
  background-image: url('background.jpg');
  background-repeat:no-repeat;
  background-size:cover;
}

</style> 


<body>
    <body style="margin:0;padding:40">
        <p>
		Saleh Hassen, sih28 <br> Samad Arshad, sa854 <br>
        </p>
    
        <p>
        <center><h2>In this project, we monitor the power usage of everyday devices and control them through a serial interface.</h2></center>
        </p>
    
        <center><img src="OutletNanny.jpg"></center>
        
        <h2>Table of Contents</h2><h3>
        <ul class="circle">
        <li><a href="#Introduction">Introduction</a></li>
        <li><a href="#HLDesign">High Level Design</a></li>
          <ul class="decimal">
          <li><a href="#BGMath">Background Math</a></li>
          <li><a href="#LStructure">Logical Structure</a></li>
          <li><a href="#tradeoffs">Trade-offs</a></li>
            <ul class="decimal">
            <li><a href="#Htradeoffs">Hardware</a></li>
            <li><a href="#Stradeoffs">Software</a></li>
            </ul>
          <li><a href="#NEC">National Electrical Code (NEC) Standards</a></li>
          <li><a href="#patenting">Patenting</a></li>
          </ul>
        <li><a href="#PHDesign">Program and Hardware Design</a></li>
          <ul class="decimal">
          <li><a href="#PDetails">Program Details</a></li>
            <ul class="decimal">
            <li><a href="#Python">Main Computer</a></li>
              <ul class="decimal">
              <li><a href="#UI">User Interface</a></li>
              <li><a href="#Plotting">Plotting</a></li>
              </ul>
            <li><a href="#PIC32">PIC32</a></li>
              <ul class="decimal">
              <li><a href="#ADC">ADC & Timer Interrupts</a></li>
              <li><a href="#UART">UART</a></li>
              <li><a href="#Timer">Timer</a></li>
              <li><a href="#Main">Main</a></li>
              </ul>
            </ul>
          <li><a href="#SRef">Software References</a></li>
          <li><a href="#HDetails">Hardware Details</a></li>
            <ul class="decimal">
            <li><a href="#current_sensor">Current Sensor</a></li>
            <li><a href="#OBox">Outlet Box</a></li>
            <li><a href="#PCircuitry">PIC32 Peripheral Circuitry</a></li>
            </ul>
          <li><a href="#HRef">Hardware References</a></li>
          <li><a href="#Bumps">Bumps in the Road</a></li>
          </ul>
        <li><a href="#results">Results</a></li>
          <ul class="decimal">
          <li><a href="#speed">Speed</a></li>
          <li><a href="#accuracy">Accuracy</a></li>
          <li><a href="#safety">Safety</a></li>
          <li><a href="#use">Usability</a></li>
          </ul>
        <li><a href="#conc">Conclusions</a></li>
          <ul class="decimal">
          <li><a href="#refl">Reflection</a></li>
          <li><a href="#futureimprovements">Improvements and in Hindsight</a></li>
          <li><a href="#safetystandards">Safety Standards Consideration</a></li>
          <li><a href="#intel">Intellectual Property</a></li>
          <li><a href="#ethics">IEEE Code of Ethics</a></li>
          <li><a href="#legal">Legal Considerations</a></li>
          </ul>
        <li><a href="#ack">Acknowledgements</a></li>
        <li><a href="#Appendix">Appendix</a></li>
        </ul>
        </h3>
    
        <a name="Introduction"></a>
        <h2>Introduction</h2>
        
        <iframe width="560" height="315" align="center" src="https://www.youtube.com/embed/GFYbF-96Wgo" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
        <p>
        We designed a power monitor that could communicate with the PIC32 through UART to give both power and current readings for any device(s) (that use NEMA plugs) plugged into our box. These readings are then accessible on a website interface, on a graph. We chose to do this project because of the growing issue of climate change and power management, allowing the client to measure their power usage and current draw. Not only that, but it’s also useful to know how much power that everyday devices use up, to minimize electricity bills.
        </p>
        
        <p>
        <blockquote>
        <b>
        Caution: We would like to warn all attempting this project that it involves live AC power supplies and the danger of electrocution. Practice electrical safety if you attempt this or a similar project and we are not accountable for the effect our device has on your health and/or devices.
        </b>
        </blockquote>
        </p>
    
        <p>
        With Saleh moving into an apartment and concerned about electricity bills for the devices he used, he wanted to measure how much power he consumes with most of his devices along with his roommates and would like to have remote control of when the devices receive power. For devices that used a fixed amount of power when on this was trivial, but certain products such as a desktop and dynamic light strip vary over time. In addition, several devices still act as a load while the device is off and he wanted a quick and safe way to monitor those devices too. The intention was to have this device connected to the internet on a private server so that a web gui can entirely control when the device is on/off and perform data acquisition on the collected information.
        </p>
    
        <p>
        Unfortunately, due to time and resource constraints, we ended up dropping this feature, mostly due to the outlet box experiencing failure and having to remanufacture the outlet box from this. 
        </p>

        <a name="HLDesign"></a>
        <h2>High Level Design</h2>
            <a name="BGMath"></a>
            <h3>Background Math</h3>
            <p>To compute power consumption, you would need the root-mean-square (RMS) of the voltage and current over one period across the device’s terminals. To simplify our project we assume the ac line is 120V that’s a pure sinusoid at 60Hz. We then measure the instantaneous current and somehow compute the RMS current, assuming the current is in phase with the AC voltage. <br> <br>
    
            Some background math we had to do included:
            <br>
            - Calculating expected current readings from different devices
            <br>
            - Getting minimum and maximum values from the ADC during a short period to get a peak-to-peak value
            <br>
            - Creating a linear equation to map those peak-to-peak values to a current
            <br>
            </p>
            
            <a name="LStructure"></a>
            <h3>Logical Structure</h3>
            <img src="logical_struc.PNG">
            
            <p>
            Our device required development on three fronts, the power path (which we nicknamed the Outlet box), the PIC32 code and peripheral circuitry for control, sampling and simple LED interface, and the computer scripts used to expand the project.
            </p>
            
            <img src="outnanny.PNG">
            
            <p>
            The outlet box is responsible for connecting the power path and providing the current sensor output needed for the PIC32 to process. The PIC32 then drives status LEDs to display basic details, measures current seen from the current sensor, provides a serial command interface for a device to request values / actions, and limits current if the measured value is greater than the set cap for an extended period of time. The onboard computer scripts initially turn on the relay, periodically request a current reading through serial, store this in a file, and plot the data over time.
            </p>
            
            <a name="tradeoffs"></a>
            <h3>Trade-offs</h3>
                <a name="Htradeoffs"></a>
                <h4>Hardware</h4>
                <p>
                We considered a few tradeoffs for hardware and software when developing the device. We had the intention of incorporating a Raspberry Pi into our project for website hosting and IoT, due to the wi-fi capabilities not working as expected and us running out of time on the project, we ended up dropping this feature. This worked in our favor in terms of our device efficiency since this would have consumed 0.5A of DC current on it’s own, making our device more wasteful to power the overhead. In addition, the 120V AC to 5V rectifier (which we nickname the “power brick”) in use was limited to 1A DC, putting us closer to being over budget for DC current consumption. In hindsight we realized a ESP8266 would have been a better fit for providing the needed connection to the internet and the use of a carbon neutral server such as Google Cloud to provide the web gui to interact with the device remotely.
                </p>
                
                <p>
                  The other major consideration was the maximum rating of current we wanted our device to be capable of measuring. Considering we wanted to make a discrete device that would fit in a 2 Gang Outlet box and reaching out to Bruce, we decided a max (AC) current rating of 5A would be appropriate. Had we had a greater amount of time to develop the product, we would have made a Computer Aided Design of the mechanical structure to get everything much more compact and developed a PCB for convenient connections for (both the power path and PIC32). Our current sensor wasn’t too sensitive (100mV/A) or had that high of a rating (+/- 20A), but it came at a lower cost for that reason, and most devices in lab were within the limit of sufficiently accurate results.
                </p> 
                <a name="Stradeoffs"></a>
                <h4>Software</h4>
                <p>
                To measure the current sensor output, we sampled from our ADC at a regular interval and computed the peak to peak seen. We could have used FFT to give us a greater idea of not only the current at the line frequency, but harmonics produced by the device. Although this would have been handy for determining device power factor, which could be used to determine theoretical efficiency, we used sampling for the ADC readings because it was simpler to implement and required much less computation. In addition, we considered plotting the data through the PIC32 on a TFT instead of using a web app interface but decided to push for some kind of web app interface in case we could get the project to work with Wi-Fi.
                </p>
                
            
            <a name="NEC"></a>
            <h3>National Electrical Code (NEC) Standards</h3>
            <p>
            Our device keeps the safety of the client in mind, following electrical regulations of the <a href="https://archive.org/details/gov.law.nfpa.nec.2014/page/n5">2014 National Electrical Code</a> within our judgement. The device is made such that accidental contact with the live AC line (120V RMS) is prevented. The Outlet box encloses all of the power path and only provides exposure to this through the client outlets and the supply plug, both of which if used properly should protect the user [<a href="https://archive.org/details/gov.law.nfpa.nec.2014/page/n45">110.27(A)</a>]. We have our own lockout/tagout procedure for our device where if working on the Outlet box circuit, we place electrical tape on the supply plug to prevent accidental energization and we remove the front plate to access it’s contents. When done accessing the Outlet box circuit we placed the front plate back on and re-energize the device. Even though the front plate doesn’t fit the PVC box snuggly, we are able to screw in the plate to the switch and use electrical tape to reinforce the protruding portions to the box. We also maintain color convention for both practice and the US National Electrical code in our power path assigning black to primary (supply) hot, white to neutral, green to AC (Protective) Ground, and red for secondary (client) hot [<a href="https://www.allaboutcircuits.com/textbook/reference/chpt-2/wiring-color-codes/">AllAboutCircuits</a>]. We pass the client ground and neutral connections on the client outlet from the supply side and pass the hot connection after the relay to client hot. Note that the electrical code states we cannot use neutral for more than one branch of the circuit unless “enters from a cable unique to the circuit that makes the grouping obvious” [<a href="https://archive.org/details/gov.law.nfpa.nec.2014/page/n52">200.4</a>]. The last regulation we’ll talk about is on Outlet Device Ampere rating where our device must be able to manage a current not less than the load to be served [<a href="https://archive.org/details/gov.law.nfpa.nec.2014/page/n61">210.21</a>]. Since we designed our Outlet box to not handle more than 5A I RMS of AC current and the box is designed to shut off the relay if such current or higher is pulled, our device meets this constraint assuming the user doesn’t set change the limit to be higher than the default. We allowed the user to change the limit greater than this for debugging and forgot to prevent this. Unfortunately, at a high enough load our current sensor output produces a voltage over our ADC reference forcing a microcontroller reset while giving the relay power! We mention a patch for this issue in the hardware section.
            </p>
            
            <a name="patenting"></a>
            <h3>Patenting</h3>
            <p>
            We realized as we were writing this report that <a href="https://patents.google.com/patent/US9106099B2/en">there is a patent for a “power monitoring system” that is very similar to our project</a>, receives power from a main supply line, offers that power conditionally to several client devices, and monitors there power consumption. In addition, they also use a microcontroller for all their data processing and control logic. 
            </p>
            
            <p>
            This patent document also includes this statement:
            <blockquote>
            “Depending on the nature of the functional state of the device and the nature of the other electrical devices, the supply of power to any or all of the other electrical devices can be shut off, so that not all electrical devices are powered in situations where power to them is unnecessary.”
            </blockquote>
            </p>
            
            <p>
            This is one of the functions of our power monitor device, where a current limit can be placed where if that limit is surpassed, the power relay is shut off.
            </p>
            
            <p>
            Not only that, but related to our user interface (UART):
            <blockquote>
            “the invention provides a user interface for use with . . . means for  receiving data output from the monitoring device relating to the monitored power output; signalling means for sending a signal in response to the received data; and control means for communicating with the monitoring device to effect a change in power consumption of at least one of the electrical devices”
            </blockquote>
            </p>
            
            <p>
            The patent linked, however, is a patent for a wired device using broad language in terms of control, communication, and distribution making it easier for our product to be included. While our original project idea was to have a wireless IoT power monitor, we ran into issues getting to finish the web portion of our project. Fortunately the patent expired in the US on December 16th, 2019.
            </p>
    
        <a name="PHDesign"></a>
        <h2>Program and Hardware Design</h2>
            <a name="PDetails"></a>
            <h3>Program Details</h3>
                <a name="Python"></a>
                <h4>Main Computer (Python)<h4>
                <p>
                    <a name="UI"></a>
                    <h5>User Interface</h5>
                    <p>
                    Our user-interface is controlled by a Python script named sera.py that reads the user’s inputs into a console, and can return useful information to the user when giving a command, such as entering 'r' to request the status of the relay, printing the current reading in a readable manner, and giving feedback of the results of entering a command like setting the current limit.
                    </p>
                    
                    <img src="getandsetcurrent.PNG"><br>
                    
                    <a name="Plotting"></a>
                    <h5>Plotting</h5>
                    <p>
                    We can plot the current values given by getCurrent() by using serial_and_pyplot.py—it appends the values to a CSV file, along with the time they were read, automatically. It also reads the CSV file and graphs a figure including every point, showing the value of the current with respect to time. This figure is saved as an image, and is able to be seen on an HTML webpage which automatically refreshes every 5 seconds, so that we can see the changes the current sensor has detected in the past 5 seconds.
                    </p>
                    
                    <img src="readcsv.PNG"><br>
                  
                    <p>
                    We also graph power usage as a function of time, using the same values of the current readings, but multiplied by 120.
                    </p>
                    
                    <img src="plotter.PNG">
                    
                </p>
                
                <a name="PIC32"></a>
                <h4>PIC32</h4>
                <p>
                We implemented our PIC32 code for the Outlet Nanny using a timer interrupt, a timer thread, a command thread, and child UART threads to send/receive. The main function initializes our setup and does round robin scheduling between the timer and command thread using a while loop. The threads are implemented with protothreads.
                </p>
                    <a name="ADC"></a>
                    <h5>ADC & Timer Interrupts</h5>
                    <img src="timer.png">
                    
                    <p>
                      We sampled at regular intervals of 3 kHz, 50 times the line frequency of 60 Hz, to get instantaneous current readings. To compute the peak to peak (pk2pk) current sensor output seen on the ADC, we would store a local maximum/minimum per period and overwrite this once a new max / min was seen. Once the period had finished, point_num is 50, we took the difference to get the peak to peak signal seen in terms of 10 bit ADC reading, then we cleared the local max / min. We would then determine the current empirically. Through several devices with fixed power ratings and a 120V RMS ac line, we estimated the expected RMS current and used a line of best fit with Google Sheets to determine how to translate a peak to peak ADC to RMS current. The current sensor is expected to deviate from it’s 2.5V bias by the one tenth of the current flowing through the device. With the transfer function seen after the low pass filter, the 10 bit ADC that uses 3.3V as reference, and the assumption that the current is a 60Hz pure sinusoid, you get the equation below. Our experimentally determined equation is very similar and the slight difference may be due to the power brick’s voltage ripple.  
                    </p>
                    
                    <img src="equations.PNG">
                    
                    <p>
                    We then reset our interrupt counter, preparing for a new period of current sensor data to poll. Lastly, once the RMS current seen by the sensor is computed we check if this is above the limit specified by the user with the ‘l’ command, if so increment the overcurrent counter, oc_cntr, by one, otherwise reset this counter to zero. This value is compared in our timer thread to determine if the device should switch to current protection mode.
                    </p>
                    
                    <a name="UART"></a>
                    <h5>UART</h5>
                    <img src="cmd.png">
                    
                    <p>
                    A thread is used to manage UART Serial communication so the microcontroller appears as a command interface when interacting with it through PuTTY. We prompt the user the device is on and continually take in their input with PT_GetSerialBuffer, use sscanf to parse command arguments from the char array, and use PT_DMA_PutSerialBuffer to transmit a response, similar to <a href="http://people.ece.cornell.edu/land/courses/ece4760/PIC32/Target_board/version_1_3_2/Serial_1_2_3_test_all.c">Serial_1_2_3_test_all.c</a> and Lab 3, however our code is a little less efficient and instead of using case statements we use if/else conditionals. The user can enter up to 16 characters per command, where the first letter is the command type and the character following this and a space character are the input argument, and terminate the command by pressing the enter/return key. One command is the user manually setting/clearing the relay, they can control it if the device isn’t in current protection mode, if so a nonzero input turns on the relay by clearing the relay control signal on the PIC32. Note that a Red LED is set and cleared the complement of the PIC32 control signal to display that the Relay is on, providing power to the client outlet sockets. A zero input sets the control signal, disabling the relay. Then a confirmation message is sent. If the device is in current protection mode, the relay control signal isn’t adjusted and the user is prompted the device is current limited. In addition other commands are:
                    
                    <ul>
                    <li>m (to manually get out of current protection mode)</li>
                    <li>i (report last rms current computed)</li>
                    <li>p (report power reading based on last current reading)</li>
                    <li>l (adjust current limit to argument value)</li>
                    <li>s (get status, whether the device is in current protection mode)</li>
                    <li>a (report raw adc reading last seen)</li>
                    </ul>
                    
                    If the user input doesn’t fall under any of the above commands, the user is prompted the command is unknown. Unfortunately this implementation is space sensitive, but is still functional and reliable. This thread yields every 100 milliseconds to give other threads several opportunities to execute, especially back when we attempted Fast Fourier Transforms for current sensor data parsing. However this yield time prevents the parsing of a command sent less than 100 ms after the previous one. In the config header file we define we are using UART and set the baud rate to 9,600.
                    </p>
                    
                    <p>
                    We use the human readable variant of the GetSerialBuffer child thread with a modification, when interacting exclusively with a human, we use the Protothreads header as is and each character received is sent back for user feedback. However once we wanted our python scripts for the computer to parse the serial response, we decided to comment out the portion of UART that sends all characters received. The machine buffer also offers this but requires more work to do so and doesn’t yield waiting for the user to input a new character but yields based on whether a DMA transfer is done. With humans typing relatively slow to the UART data transaction, we get better CPU Utilization using the human readable pthread. Even when our computer is interacting with the device via python script since we would want to send our commands only so often. To make this change we only need to vary GetSerialBuffer in <a href="https://raw.github.coecis.cornell.edu/gist/sa854/6608aff0b39048ff4e2c97c5667d2ca5/raw/f3cd45f3be7b379aaf4bfa6fa92ca6cb68226989/pt_cornell_1_3_2.h?token=AAAA55HUMUZSODIMUQM5MNS6ALU54">pt_cornell_1_3_2.h.</a>
                    </p>
                    
                    <a name="Timer"></a>
                    <h5>Timer</h5>
                    <img src="pic32timer.png">
                    
                    <p>
                    A timer thread is used to toggle a heartbeat LED and check if the device over current counter is over 100, which means for over 1.6 seconds the RMS current is greater than the limit.  Under this condition, the current protection LED is set, and the relay (with it’s LED) is shut off, cutting off client power outlet sockets. The reason why we check if we pulled our current limit for a set amount of time in the timer thread was to guarantee the device cannot enter current protection mode in less than a second of duration with the thread acting as a buffer since this thread can only execute once a second and the timer oc_cntr is required to be greater than 100. Since the counter can only increment at 60Hz, the first execution of the timer thread immediately after the oc_cntr is reset to zero can’t set off current protection mode.
                    </p>
                    
                    <a name="Main"></a>
                    <h5>Main</h5>
                    <img src="main.png">
                    
                    <p>
                    In our main function, we first disable analog inputs by clearing the analog select registers and then setup our ADC. We used an initial setup of our ADC similar to Bruce’s <a href="http://people.ece.cornell.edu/land/courses/ece4760/PIC32/Target_board/version_1_3_2/TFT_ADC_read.c">TFT_ADC_read.c</a>. We use the 3.3V voltage rails with no auto sampling (meaning we need to acquire a sample before reading from our ADC), no offset calibrated, using half the system clock speed (20 MHz), using analog channel 11 (Pin RB13). We then configure a timer such that it occurs at a rate of 3 kHz (compromised to 3,004.8 Hz to use a larger prescaler from peripheral clock).  Afterwards we declared our Digital outputs, as shown below.
                    </p>
                    
                    <img src="outputtable.PNG">
                    
                    <p>
                    We then enable interrupts and then begin initializing our two parent protothreads: timer and cmd. The child threads (for UART transmit/receive) do not have to be initialized here and are spawned as needed. Finally we execute the threads with a round-robin scheduler utilizing a while loop.
                    </p>
                    
                    <img src="interrupts.PNG"><br>
            
            <a name="SRef"></a>
            <h3>Software References</h3>
            <a href="https://pyserial.readthedocs.io/">pySerial Library and Examples</a><br>
            <a href="https://matplotlib.org/">Matplotlib Library and Examples</a><br>
            <a href="http://people.ece.cornell.edu/land/courses/ece4760/">Professor Land’s ADC/UART code (Labs 2 and 3) and his Protothreads interface</a><br>
            <a href="http://hades.mech.northwestern.edu/index.php/PIC32MX:_Benchmarking_Mathematical_Operations#Multiplication_.28Test_32.29">PIC32MX: Benchmarking Mathematical Operations</a><br>
            
            <a name="HDetails"></a>    
            <h3>Hardware Details</h3>
                <a name="current_sensor"></a>
                <h4>Current Sensor</h4>
                <img src="csensor.PNG">
                <p>
                Our project relied on finding a feasible current sensor: given a current passing through or near the device, an output voltage proportional (or somewhat related) to this current is seen that wouldn’t bottleneck the desired RMS current of 5A or less. Furthermore, the voltage of the current being sensed would be 120 V RMS, with peak voltages near +/- 170 V, so isolation between the voltage output and the current sensor would be desirable. We looked at several devices but determined the ACHS7122 would fit our needs very well. The device requires the measured current to go through the device, entering on Pin 1 and 2 and exiting on Pin 3 and 4. Since current generates a magnetic field and with a Hall effect sensor it can measure a voltage across a Hall element due to a magnetic field, the ACHS7122 can measure the current passing through the device with great accuracy. The sensitivity of the device is 100mV/A and the zero current offset is halfway between Vdd and ground. An offset from ground is needed since the PIC32 will measure this through it’s ADC and our current setup requires the output voltage to be between ground and 3.3V. If the current through the device and it’s sensitivity attempts to produce an output voltage below ground or above it’s input voltage, it would saturate at its respective rail.
                </p>
                
                <img src="solder.PNG">
                
                <p>
                We populated the current sensor on an adapter board the course provided by Adafruit that made the SOIC footprint component compatible with solder boards and increased conduction for the current terminals. The image above shows the components placed on a small solder board without the hot wires in our power path soldered (would be connected to the left side).  Under the tape is our two capacitors needed to set bandwidth and a bypass capacitor as the two are prone to shorting each other with how we placed them. We then tested the sensor on it’s own with 2 DC power supplies and a 4 ohm high-wattage resistor. We powered the current sensor with 5V and drove a separate 5V through the resistor load with the current sensor’s current terminals in series. We expected the current sensor output to be:
                
                <blockquote>
                2.5V + (0.1V/A)(1.25A) = 2.625V
                </blockquote>
                </p>
                
                <img src="osci.PNG">
                
                <p>
                Through the oscilloscope when the load power supply was turned on we found the measured output was 2.62V, within 4% error. 
                </p>

                
                <a name="OBox"></a>
                <h4>Outlet Box</h4>
                <img src="outletbox_schem.png">
                
                <p>
                Once we confirmed our current sensor, we developed the outlet box with an incremental approach in mind while avoiding as many temporary connections as possible. We first needed to test the functionality of the relay Bruce provided us, the G3NE-210T-US-DC5, but didn’t want to risk accidental execution. For this reason we asked Bruce for an old power strip and removed it’s mechanical switch with our relay and confirmed whether we could control the relay to conduct if a 5V signal was provided on it’s input side. Note unlike the previous 4760 projects, this project required thick wiring to provide sufficient conduction for our power path. This prevented us from utilizing simple connection methods such as small jumpers and breadboards to connect & test our outlet box circuit. To connect a relay to the extension cord’s supply and client hot power while making it convenient to swap between the temporary extension cord and our future device, we used socket crimp connectors and 12 AWG wire with some soldering. 
                </p>
                
                <img src="relayblock.PNG">
                
                <p>
                We confirmed this and then designed our Outlet box schematic. We first pictured the trivial case of an extension cord where the Neutral, Hot, and GFCI connections on our supply plug would be forwarded to the client sockets. We connected to the client socket via screw terminals on 12 AWG wires with the strands soldered together. We then added a mechanical switch that could control whether the entire device has power or not. We intended this as a safety precaution in case our device fails, we’d like to offer a quick way to (attempt to) disconnect the device from the AC line. Placing the switch any later in the power path would fail to disconnect the AC line for all other portions of the outlet box. We then passed the hot wire after our mechanical switch through our current sensor and then to the relay. We then connected the other load terminal of our relay to the hot terminal of the client outlets. Afterwards, we excluded the 5V power brick needed to convert the supply line to 5V DC (for our current sensor and PIC32), to first confirm the outlet box behaves like an extension cord, but along with a mechanical switch, there are relay wires which require a 5v input to turn on the client device’s power. We found the device passed this functionality.
                </p>
                
                <img src="wires.PNG">
                
                <p>
                Then we prepared the wiring needed to power the 5V power brick. We had to offer two more connections for our outlet box, one on the hot connection after our current sensor to our power brick, and neutral to power brick. The plug terminal used on the brick made it convenient to connect to with socket crimp connectors. We wanted our device to be able to measure its own power usage and current consumption so we wanted to make the power brick used to power our PIC32 and other 5V logic was in series with our current sensor.
                </p>
                
                <img src="noplate.PNG">
                
                <p>
                Keep in mind the above images are before our final pass of electrical tape applied to insulate connections and prevent shorts. When it was time to put everything into the PVC box, we had a frustrating time to get it all to fit. We underestimated the physical resistance to reroute 12 AWG wires. We placed the power. The final physical placement involved the power brick underneath the switch, the relay underneath the client sockets, and the current sensor a little below and next to the switch. Once we had the physical placement down we found the relay control lines, current sensor output, 5V, and ground all needed to be routed out of the box and convenient side drill holes would be desired. We made the holes and put the device back together again this time testing both control over the client power while measuring the current sensor output with an oscilloscope.
                </p>
                
                <p>
                When our current sensor broke we attempted to develop our own AC current clamp as a replacement. The device would behave like a transformer and show a smaller but proportional current on the secondary winding proportional to the primary wire’s. We attempted this until we had to leave for thanksgiving break since we lost our spare components and wouldn’t get our replacements until after break. Unfortunately, this rushed attempt failed, most likely due to the lack of quality of the transformer we made, we salvaged an old core magnet and made about 80 windings by hand with some accidental overlap between every few turns.
                </p>
                
                <a name="PCircuitry"></a>
                <h4>PIC32 Peripheral Circuitry</h4>
                <img src="board_and_per.png"><br>
                
                <p>
                The last portion of our project we developed hardware for was the solder board & small PIC32 board used to put our PIC32 Peripheral circuitry together. This included the low pass filter on our current sensor readings, three status LEDs, UART communication lines, and an inverter to drive the relay with 5V or ground.
                </p>
                
                <img src="smallboard.PNG"><br>
                
                <p>
                The above picture is the solder board for the PIC32 small board and peripheral circuits. We apologize that this is the only image we had of the board. We followed the instructions provided to populate the Small Sean Carroll PIC32 board and flashed code to toggle one of the LEDs per second to confirm it works.
                </p>
                
                <p>
                We determined a low pass filter was desired since we wanted to pass 60 Hz current sensor readings while ignoring the higher frequency content. We also wanted to have a resistance of less than 1kOhm with our current ADC configuration. We ended up choosing a 100 ohm resistor & 10uF capacitor, giving us a cutoff frequency of 159 Hz. Note that because our pass band allows the current sensor output to pass through with nearly no voltage drop and our ADC configuration to use 3.3V and ground, we have an implicit maximum current limit of 8A. If a device pulls more current than this, the ADC will force the microcontroller to restart. We were unable to change this in time but we recommend a resistor in parallel with the low pass’s capacitor so the current sensor output is readable by the microcontroller for a greater range of load currents.
                </p>
                
                <p>
                The inverter acts as a buffer so we can drive 5V on the relay through the PIC32’s 3.3V. This way the current needed to drive the relay isn’t driven from the PIC32 but the 5V supply line Vin. Vin is the voltage seen from the Small PIC32 board that’s on only if the small board’s switch is on. This prevents the relay from being turned on while the PIC32 is off.
                </p>

            <a name="HRef"></a>
            <h3>Hardware References</h3>
            <a href="https://archive.org/details/gov.law.nfpa.nec.2014/page/n5">2014 National Electrical Code</a><br>
            <a href="https://www.lowes.com/pd/Legrand-2-Gang-White-Double-Standard-Wall-Plate/1000397809?cm_mmc=shp-_-c-_-prd-_-rpe-_-google-_-pla-_--_-soswiringdevices-_-1000397809-_-0&placeholder=null&gclid=EAIaIQobChMIodaLxbK75gIVjJ-zCh0PnwjVEAQYASABEgL7mfD_BwE&gclsrc=aw.ds">2-Gange Outlet and Switch Plate</a><br>
            <a href="https://en.wikipedia.org/wiki/AC_power_plugs_and_sockets">AC Plugs and Sockets</a><br>
            <a href="https://docs.broadcom.com/docs/ACHS-712x-DS101">ACHS 7122 (Current Sensor) Datasheet</a><br>
            <a href="http://people.ece.cornell.edu/land/courses/ece4760/PIC32/index_ADC.html">Analog/Digital Converter</a><br>
            <a href="https://www.lowes.com/pd/Legrand-White-15-Amp-Duplex-Residential-Outlet/3235958">Duplex Outlet Socket</a><br>
            <a href="https://www.mouser.com/datasheet/2/307/g3ne_ds_e_4_1_csm166-1221231.pdf">G3NE-210T-US-DC5 (Relay) Datasheet</a><br>
            <a href="https://en.wikipedia.org/wiki/Load_factor_(electrical)">Load Factor</a><br>
            <a href="https://www.electronoobs.com/eng_circuitos_tut12.php">Non-invasive Current Clamp</a><br>
            <a href="https://www.lowes.com/pd/CARLON-2-Gang-Blue-PVC-New-Work-Standard-Switch-Outlet-Wall-Electrical-Box/50053877">PVC 2-Gang Outlet Box</a><br>
            <a href="https://www.lowes.com/pd/Eaton-15-Amp-Single-pole-White-Toggle-Residential-Light-Switch/1098293">SPST Switch 120V/15A</a><br>
            <a href="http://people.ece.cornell.edu/land/courses/ece4760/PIC32/index_UART.html">Universal Asynchronous Receiver-Transmitter (UART) Serial</a><br>
            <a href="https://www.youtube.com/watch?v=wpAA3qeOYiI ">What is Hall Effect and How Hall Effect Sensors Work</a><br>
            <a href="https://nurdspace.nl/images/e/e0/ESP8266_Specifications_English.pdf">Considered: ESP8226 (Wifi Module) Datasheet</a><br>

            <a name="Bumps"></a>
            <h3>Bumps in the Road</h3>
            <ul>
            <li>The Raspberry Pi Zero W’s internet capabilities did not work with Cornell’s wi-fi. We were unable to forward a wifi connection from a computer through serial (before we realized the constraints of WLAN).</li>
            <li>Some electrical devices cause UART to send seemingly random characters.</li>
            <li>Using a small container for our device rather than a larger one made hardware debugging slightly more time consuming.</li>
            <li>The current sensor broke at one point, and we couldn’t get any oscilloscope readings, forcing us to replace it, retesting the sensor and reintegrating it in our outlet box.</li>
            <li>We tried building a current sensor ourselves when our first one broke, but it ended up not working.</li>
            <li>Using FFT for the ADC readings was a futile effort, as the regular sampling method was what we ended up using, and it was within about 11% error of actual values. The FFT implementation was not worth the time and effort, but could be a good improvement in the future.</li>
            </ul>
        
        <a name="results"></a>
        <h2>Results</h2>
            <a name="speed"></a>
            <h3>Speed</h3>
            <p>
            Our UART sends a data point about once a second, and our web page containing the graph of the current readings as a function of time refreshes every five seconds. All commands sent through UART give virtually instant results. With a baudrate of 9,600 we can transmit 1,200 bytes per second assuming peak efficiency but our PIC32 code prevents a serial command from being processed within 100ms after the response of another command has been handled. For humans typing into a serial interface this is fine but for our PySerial scripts this delay is present in those scripts as well. Since there are no other threads that demand ASAP utilization of the processor, we could have made the yield time shorter on our microcontroller or make our threads pre-emptive and use this for UART but we decided not to since the delay in pySerial code isn’t significant.
            </p>
            
            <p>
            Current limiting for a device that is consistently over it’s RMS limit takes about 1-2 seconds, responding fast enough to shut off client devices in case of accidental shorts or underestimated loads while forgiving client devices for any transient start up. 
            </p>
            
            <p>
            We did not measure the cycle duration of our interrupt or threads but none of these processes require quick or efficient computation. As such we took the lazy approach and did an expensive operation in our interrupt: multiplying a float. Assuming all other operations are negligible and using <a href="http://hades.mech.northwestern.edu/index.php/PIC32MX:_Benchmarking_Mathematical_Operations#Multiplication_.28Test_32.29">this</a> source we believe it would take 736ns to compute this. Although expensive, it would only prevent interrupts executing at 1.35MHz or above from timely finishing before the next interrupt. However this does hurt our CPU utilization time so we could improve this by using fixed point and computing the RMS current with this.
            </p>
            
            <a name="accuracy"></a>
            <h3>Accuracy</h3>
            <img src="accuracy.PNG">
            <p>
            Our current readings were within about 11% of the expected results.The current sensor device itself has an error margin of 10%, so we think we’ve done a good job at keeping the error relatively low. We could slightly decrease the error on the PIC32 side by sampling at a faster rate, giving us more data points and less of a difference between our actual max/min and the one we were able to find through sampling but 50 data points per period seems to only increase the error by 1%.
            </p>
            
            <a name="safety"></a>
            <h3>Safety</h3>
            <p>
            None of our wires in our power path are exposed and are well-insulated, in the box or outside of it. We also maintained a tag-out/lock-out system to prevent accidental electrocution. We made sure every connection besides those connecting between the PIC32 and Outlet box were soldered well to avoid any open circuits. Our device also included a switch, which can turn off the device completely. In our UART program, our system starts with the relay off (r = 0) as an additional safeguard. Most of the wires used in this device are contained in a small PVC box that we screwed shut, so there’s absolutely no exposed wiring in our device that’s on the 120V line. Finally, there’s a default current limit set when the device is connected, which is 5A. If the current sensor reads any current value higher than this, it will turn off the relay.
            </p>
            
            <a name="use"></a>
            <h3>Usability</h3>
            <p>
            Our device starts with ‘safe’ default settings (the relay is off, current limit is 5A) for first-time users. When giving a command in the serial console, the result of the command is echoed back to the user, so that they can see if their command went through, and what the result of it was. However if the device pulls a significant amount of current, 10A or more, the Microcontroller will reset due to the ADC, the relay will remain on, and the client device will remain powered until our power path devices rated at 5A fails. This is a quick issue to patch as mentioned in the hardware section, either adjust the ADC voltage reference and/or adjust the filter between the current sensor and the ADC. This issue also caused weird characters to be printed on the serial interface. The only way someone could hurt themselves using this device (outside of the high load issue) is by either breaking it open and ripping the insulation off, or sticking a piece of metal into the electrical outlets.
            </p>
            
            <p>
            The Serial command interface is pretty limiting on who could use our device but at the same time python scripts could automate most of the commands given to the device and only require initial setup. Often we found ourselves debugging why the client devices weren’t receiving any power and realized we forgot something such as flipping the switch, connecting the relay wires to the inverter, or plugging in the Outlet Nanny itself. The status LEDs were a huge help to gauge what had power. 
            </p>
        
        <a name="conc"></a>
        <h2>Conclusions</h2>
            <a name="refl"></a>
            <h3>Reflection</h3>
            <p>
            During the project, we were worried about the accuracy of our current readings, and once we tested them, we ended up seeing that our accuracy was very close to the accuracy margin of the current sensor itself—11% vs 10%. 
            </p>
            
            <p>
            When we started this project, we expected Raspberry Pi implementation to not be the most difficult part, but for reasons we don’t really understand, our Raspberry Pi Zero couldn’t work with Cornell’s wi-fi. Because of this, we switched to a Raspberry Pi 3 pretty late into our project and despite attempts to provide some wireless connection to the internet, including an AWS server that would act as a middleman between the client’s web browser and the raspberry pi, we were unable to setup a wireless connection in time that we could develop with. Had we not needed to remanufacture the Outlet box due to current sensor failure the saved time could have made the difference. In the end, our device must be wired to a computer to read the current values, which was not what we originally wanted.
            </p>
            
            <p>
            We <i>did</i> expect the hardware work to be the most time-consuming part of our project, and that it was. As for hardware debugging, aside from needing to replace the current sensor because our first one was fried, we hit our goal.
            </p>
            
            <a name="futureimprovements"></a>
            <h3>Improvements and in Hindsight</h3>
            <p>
            We could improve our device on three fronts, remote access, improved data processing, and fixing the current sensing flaw if under high load.
            </p>
           
            <p>
            Our project intended to have Wi-fi connectivity so a client could monitor and control their devices. To provide that we may be dropping any consideration of a Raspberry Pi and using a ESP8226 Module, as well as make our web GUI look much more appealing, and be able to control the device without typing into a console. We haven’t looked into this alternative too much but would save us in terms of device overhead power consumption but would rely on PIC32 code to connect us to a server and a server to connect to such as Google Cloud. In hindsight we realized that the Pi Zero W uses WLAN which requires another device with WLAN and internet to connect the raspberry pi to the internet while the Pi 3 can connect to the internet via Wi-Fi or Ethernet but dissipates so much power. 
            </p>
            
            <p>
            FFT could also be considered so we could not only measure the current sensor at the line’s fundamental frequency but it’s harmonics too to determine the client device(s)’s power factor and reporting back it’s maximum possible efficiency. This feature would require a lot more data processing and computation on our PIC32.
            </p>
            
            <p>
            The last feature change would be to account for high load device current draw and to be able to handle the full sweep of the current sensor’s output on our PIC32 ADC. The easiest and quickest fix is to place a resistor in parrallel with the low pass’s capacitor to have a voltage divider for our pass through frequencies but we’d need to readjust our equation to adjust an ADC reading to an RMS current. This is the least costly to readjust.
            </p>
            
            <a name="safetystandards"></a>
            <h3>Safety Standards and Consideration</h3>
            Our device cannot harm someone unless the PVC box and/or the insulation is broken, or if the hot and neutral pins of either of outlets are shorted by a piece of conductive material, like any other outlet. We’ve insulated every previously exposed 120V wire or hot connections. Our device can also be turned off without needing to be unplugged. 
            
            <a name="intel"></a>
            <h3>Intellectual Property</h3>
            <p>We based our code for UART communication off of Bruce’s given code for Lab 3, and we also used his Protothreads interface. Our Python UART-read code was based off of simple examples and documentation given for the library “PySerial”, and the same for the Python library “Matplotlib”.</p>
            <p>No patent opportunities are foreseen for the project at this point.</p>
            
            <a name="ethics"></a>
            <h3>IEEE Code of Ethics</h3>
            We have agreed to follow IEEE’s code of ethics before doing this project, some specific steps we’ve taken to ensure this are:
            <ul>
            <li>We have made our device so that it's not any more dangerous than a regular electrical outlet.</li>
            <li>We only use actual data to make any claims and estimates.</li>
            <li>We’ve talked with Bruce about our limitations and we’ve taken the correct safety precautions working on this project.</li>
            <li>We have followed standard IEEE safety precautions when working with this project.</li>
            </ul>
            
            <a name="legal"></a>
            <h3>Legal Considerations</h3>
            We would like to warn all attempting this project that it involves live AC power supplies and the danger of electrocution. Practice electrical safety if you attempt this or a similar project and we are not accountable for the effect our device has on your health and/or devices.
            
        <a name="ack"></a>
        <h2>Acknowledgements</h2>
        We would like to thank Bruce Land for being a great mentor and teacher throughout the course, as well as the TAs of Fall 2019.
            
        <a name="Appendix"></a>
        <h2>Appendix</h2>
        <p>The group approves this report for inclusion on the course website.</p>
        <p>The group approves the video for inclusion on the course youtube channel.</p>
        
            <h3>Program Listing</h3>
                <h4><a href="https://raw.github.coecis.cornell.edu/sih28/ece4760-final-project/master/Big_board_pt_1_3_2/main_4760_final.c?token=AAABN6YGYP3VNBVLP4QA5ZC6AMTKA">Main PIC32 Code (C)</a></h4>

                <h4><a href="https://raw.github.coecis.cornell.edu/sih28/ece4760-final-project/master/Big_board_pt_1_3_2/config_1_3_2.h?token=AAAA55BUGSJNRVSZWT3JD5C6AN5QM">Configuration header (C)</a></h4>

                <h4><a href="https://raw.github.coecis.cornell.edu/sih28/ece4760-final-project/master/Big_board_pt_1_3_2/pt_cornell_1_3_2.h?token=AAAA55FWSWVU5L7L3B76MWS6AN5RU">Altered protothreads header (C)</a></h4> 
                
                <h4><a href="https://raw.github.coecis.cornell.edu/sih28/ece4760-final-project/master/raspberrypicode/sera.py?token=AAABN64KYWX7ZSTY65JVWFC6AMTRY">Serial Input Code (Python)</a></h4>
                
                <h4><a href="https://raw.github.coecis.cornell.edu/sih28/ece4760-final-project/master/raspberrypicode/serial_and_pyplot.py?token=AAABN667GXWH2TBE5JJ6ZN26AMTOG">Current Plotting Code (Python)</a></h4>
                
            
            <h3>Hardware Schematics</h3>
            <img src="outletbox_schem.png">
            <img src="board_and_per.png">
            <h4><a href="https://github.com/saleh99er/ece4760_final_project_outlet_nanny/tree/master/Schematic">Schematic of project (Kicad)</a></h4>
            
            <h3><a href="https://docs.google.com/spreadsheets/d/18cqE4Pgc4_iT54x_7nFSSPi_hINx9QCSq084MaUKshM/edit?usp=sharing">Bill of Materials</a></h3>
            <img src="budget.png">
            
            <h3>Division of Labor</h3>
            <img src="work.PNG"><br>
            
            <h3>Full Source Listing</h3>
            <a href="https://archive.org/details/gov.law.nfpa.nec.2014/page/n5">2014 National Electrical Code</a><br>
            <a href="https://www.lowes.com/pd/Legrand-2-Gang-White-Double-Standard-Wall-Plate/1000397809?cm_mmc=shp-_-c-_-prd-_-rpe-_-google-_-pla-_--_-soswiringdevices-_-1000397809-_-0&placeholder=null&gclid=EAIaIQobChMIodaLxbK75gIVjJ-zCh0PnwjVEAQYASABEgL7mfD_BwE&gclsrc=aw.ds">2-Gange Outlet and Switch Plate</a><br>
            <a href="https://en.wikipedia.org/wiki/AC_power_plugs_and_sockets">AC Plugs and Sockets</a><br>
            <a href="https://docs.broadcom.com/docs/ACHS-712x-DS101">ACHS 7122 (Current Sensor) Datasheet</a><br>
            <a href="http://people.ece.cornell.edu/land/courses/ece4760/PIC32/index_ADC.html">Analog/Digital Converter</a><br>
            <a href="https://www.lowes.com/pd/Legrand-White-15-Amp-Duplex-Residential-Outlet/3235958">Duplex Outlet Socket</a><br>
            <a href="https://www.mouser.com/datasheet/2/307/g3ne_ds_e_4_1_csm166-1221231.pdf">G3NE-210T-US-DC5 (Relay) Datasheet</a><br>
            <a href="https://en.wikipedia.org/wiki/Load_factor_(electrical)">Load Factor</a><br>
            <a href="https://matplotlib.org/">Matplotlib Library and Examples</a><br>
            <a href="https://www.electronoobs.com/eng_circuitos_tut12.php">Non-invasive Current Clamp</a><br>
            <a href="http://hades.mech.northwestern.edu/index.php/PIC32MX:_Benchmarking_Mathematical_Operations#Multiplication_.28Test_32.29">PIC32MX: Benchmarking Mathematical Operations</a><br>
            <a href="http://people.ece.cornell.edu/land/courses/ece4760/">Professor Land’s ADC/UART code (Labs 2 and 3) and his Protothreads interface</a><br>
            <a href="https://www.lowes.com/pd/CARLON-2-Gang-Blue-PVC-New-Work-Standard-Switch-Outlet-Wall-Electrical-Box/50053877">PVC 2-Gang Outlet Box</a><br>
            <a href="https://pyserial.readthedocs.io/">pySerial Library and Examples</a><br>
            <a href="https://www.lowes.com/pd/Eaton-15-Amp-Single-pole-White-Toggle-Residential-Light-Switch/1098293">SPST Switch 120V/15A</a><br>
            <a href="http://people.ece.cornell.edu/land/courses/ece4760/PIC32/index_UART.html">Universal Asynchronous Receiver-Transmitter (UART) Serial</a><br>
            <a href="https://www.youtube.com/watch?v=wpAA3qeOYiI ">What is Hall Effect and How Hall Effect Sensors Work</a><br>
            <a href="https://nurdspace.nl/images/e/e0/ESP8266_Specifications_English.pdf">Considered: ESP8226 (Wifi Module) Datasheet</a><br>
            <a href="http://people.ece.cornell.edu/land/courses/ece4760/PIC32/Target_board/version_1_3_2/TFT_ADC_read.c">TFT_ADC_read.c</a><br>
            <a href="http://people.ece.cornell.edu/land/courses/ece4760/PIC32/Target_board/version_1_3_2/Serial_1_2_3_test_all.c">Serial_1_2_3_test_all.c</a><br>
            <a href="https://gist.github.coecis.cornell.edu/sa854/6608aff0b39048ff4e2c97c5667d2ca5">pt_cornell_1_3_2.h</a><br>
</body>
</html>